--!strict
-- XuilanLib.lua (ModuleScript in ReplicatedStorage)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local XuilanLib = {}
XuilanLib.__index = XuilanLib

-- ===== Helpers =====
local function ParseFont(fontName: any): Enum.Font
	if typeof(fontName) == "EnumItem" then
		return fontName
	end
	if typeof(fontName) == "string" and Enum.Font[fontName] then
		return Enum.Font[fontName]
	end
	return Enum.Font.SourceSans
end

local function ParseColor(color: any): Color3
	if typeof(color) == "Color3" then
		return color
	end

	if typeof(color) == "table" then
		return Color3.fromRGB(color[1] or 255, color[2] or 255, color[3] or 255)
	end

	if typeof(color) == "string" then
		-- HEX
		local hex = color:gsub("#", "")
		if #hex == 6 then
			local r = tonumber(hex:sub(1, 2), 16)
			local g = tonumber(hex:sub(3, 4), 16)
			local b = tonumber(hex:sub(5, 6), 16)
			if r and g and b then
				return Color3.fromRGB(r, g, b)
			end
		end

		-- "255,255,255"
		local r, g, b = string.match(color, "(%d+),%s*(%d+),%s*(%d+)")
		if r and g and b then
			return Color3.fromRGB(tonumber(r), tonumber(g), tonumber(b))
		end
	end

	return Color3.fromRGB(255, 255, 255)
end

local function brighten(c: Color3, add: number): Color3
	return Color3.fromRGB(
		math.clamp(c.R * 255 + add, 0, 255),
		math.clamp(c.G * 255 + add, 0, 255),
		math.clamp(c.B * 255 + add, 0, 255)
	)
end

-- ===== Window Factory =====
function XuilanLib:CreateWindow(settings: any)
	settings = settings or {}

	local player = Players.LocalPlayer
	if not player then return nil end
	local playerGui = player:WaitForChild("PlayerGui")

	-- remove old instance (optional)
	local oldGui = playerGui:FindFirstChild("CustomRectangleGui")
	if oldGui then oldGui:Destroy() end

	-- ScreenGui
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "CustomRectangleGui"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.DisplayOrder = 999999
	screenGui.Parent = playerGui

	-- === SAME LOOK CONSTANTS AS CURRENT GUI ===
	local MAIN_SIZE = UDim2.new(0, 400, 0, 280)
	local MAIN_COLOR = Color3.fromRGB(18, 18, 18)
	local MAIN_T = 0.12
	local MAIN_CORNER = 14

	local INNER_SIZE = UDim2.new(0, 260, 0, 235)
	local INNER_COLOR = Color3.fromRGB(140, 140, 140)
	local INNER_T = 0.8
	local INNER_CORNER = 14

	local ROW_HEIGHT = 34
	local ROW_CORNER = 12
	local ROW_BG = Color3.fromRGB(160, 160, 160)
	local ROW_BG_T = INNER_T
	local ROW_TEXT_DEFAULT = Color3.fromRGB(255, 255, 255)
	local MUTED_TEXT_DEFAULT = Color3.fromRGB(200, 200, 200)
	local TEXT_SIZE = 15

	local ACCENT_GREEN = Color3.fromRGB(39, 227, 36)

	-- Header spacing
	local HEADER_TOP = 3
	local HEADER_BOTTOM = 3
	local LEFT_TO_IMAGE = 10
	local IMAGE_TO_TEXT = 10
	local ICON_MARGIN = 10
	local ICON_GAP = 10

	-- Toggle pill
	local DOT = 13
	local PILL_PAD = 2
	local PILL_W = (DOT * 2) + (PILL_PAD * 2)
	local PILL_H = DOT + (PILL_PAD * 2)
	local PILL_OFF = Color3.fromRGB(150, 150, 150)

	-- assets (same as your current)
	local ASSET_PUG = settings.Icon or "rbxassetid://136007050760089"
	local ASSET_CLOSE = "rbxassetid://87923978940368"
	local ASSET_MINUS = "rbxassetid://92670491990824"

	-- Title/Desc settings (with parsing)
	local windowTitle = settings.Title or "Xuilan Window"
	local windowDesc = settings.Description or ""
	local titleFont = ParseFont(settings.TitleFont or "SourceSansBold")
	local descFont = ParseFont(settings.DescriptionFont or "SourceSansBold")
	local titleColor = ParseColor(settings.TitleColor or "#ebebeb")
	local descColor = ParseColor(settings.DescriptionColor or "200,200,200")

	-- MAIN FRAME
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainRectangle"
	mainFrame.Size = MAIN_SIZE
	mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	mainFrame.BackgroundColor3 = MAIN_COLOR
	mainFrame.BackgroundTransparency = MAIN_T
	mainFrame.BorderSizePixel = 0
	mainFrame.Active = true
	mainFrame.ZIndex = 1000
	mainFrame.Parent = screenGui

	local mainCorner = Instance.new("UICorner")
	mainCorner.CornerRadius = UDim.new(0, MAIN_CORNER)
	mainCorner.Parent = mainFrame

	-- INNER FRAME
	local innerFrame = Instance.new("Frame")
	innerFrame.Name = "InnerRectangle"
	innerFrame.Size = INNER_SIZE
	innerFrame.AnchorPoint = Vector2.new(1, 1)
	innerFrame.Position = UDim2.new(1, -10, 1, -10)
	innerFrame.BackgroundColor3 = INNER_COLOR
	innerFrame.BackgroundTransparency = INNER_T
	innerFrame.BorderSizePixel = 0
	innerFrame.ZIndex = 1001
	innerFrame.Parent = mainFrame

	local innerCorner = Instance.new("UICorner")
	innerCorner.CornerRadius = UDim.new(0, INNER_CORNER)
	innerCorner.Parent = innerFrame

	-- Inner mask (prevents overflow at corners)
	local innerMask = Instance.new("Frame")
	innerMask.Name = "InnerMask"
	innerMask.BackgroundTransparency = 1
	innerMask.BorderSizePixel = 0
	innerMask.ClipsDescendants = true
	innerMask.ZIndex = 1002
	innerMask.Size = UDim2.new(1, 0, 1, 0)
	innerMask.Position = UDim2.new(0, 0, 0, 0)
	innerMask.Parent = innerFrame

	local innerMaskCorner = Instance.new("UICorner")
	innerMaskCorner.CornerRadius = UDim.new(0, INNER_CORNER)
	innerMaskCorner.Parent = innerMask

	-- IMAGE (pug)
	local image = Instance.new("ImageLabel")
	image.Name = "TopLeftImage"
	image.BackgroundTransparency = 1
	image.BorderSizePixel = 0
	image.Image = ASSET_PUG
	image.ScaleType = Enum.ScaleType.Fit
	image.ZIndex = 1002
	image.Parent = mainFrame

	-- HEADER TEXT WRAP
	local textWrap = Instance.new("Frame")
	textWrap.Name = "TextWrap"
	textWrap.BackgroundTransparency = 1
	textWrap.BorderSizePixel = 0
	textWrap.ZIndex = 1002
	textWrap.Parent = mainFrame

	local headerPad = Instance.new("UIPadding")
	headerPad.PaddingTop = UDim.new(0, 2)
	headerPad.PaddingBottom = UDim.new(0, 2)
	headerPad.Parent = textWrap

	local headerList = Instance.new("UIListLayout")
	headerList.FillDirection = Enum.FillDirection.Vertical
	headerList.SortOrder = Enum.SortOrder.LayoutOrder
	headerList.Parent = textWrap

	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.BackgroundTransparency = 1
	title.BorderSizePixel = 0
	title.Text = windowTitle
	title.TextColor3 = titleColor
	title.Font = titleFont
	title.TextScaled = true
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextYAlignment = Enum.TextYAlignment.Top
	title.ZIndex = 1003
	title.LayoutOrder = 1
	title.Parent = textWrap

	local desc = Instance.new("TextLabel")
	desc.Name = "Description"
	desc.BackgroundTransparency = 1
	desc.BorderSizePixel = 0
	desc.Text = windowDesc
	desc.TextColor3 = descColor
	desc.Font = descFont
	desc.TextScaled = true
	desc.TextXAlignment = Enum.TextXAlignment.Left
	desc.TextYAlignment = Enum.TextYAlignment.Top
	desc.ZIndex = 1003
	desc.LayoutOrder = 2
	desc.Parent = textWrap

	-- ICONS
	local closeBtn = Instance.new("ImageButton")
	closeBtn.Name = "CloseButton"
	closeBtn.BackgroundTransparency = 1
	closeBtn.BorderSizePixel = 0
	closeBtn.AutoButtonColor = false
	closeBtn.AnchorPoint = Vector2.new(1, 0)
	closeBtn.Image = ASSET_CLOSE
	closeBtn.ScaleType = Enum.ScaleType.Fit
	closeBtn.ZIndex = 2000
	closeBtn.Parent = mainFrame

	local minusBtn = Instance.new("ImageButton")
	minusBtn.Name = "MinusButton"
	minusBtn.BackgroundTransparency = 1
	minusBtn.BorderSizePixel = 0
	minusBtn.AutoButtonColor = false
	minusBtn.AnchorPoint = Vector2.new(1, 0)
	minusBtn.Image = ASSET_MINUS
	minusBtn.ScaleType = Enum.ScaleType.Fit
	minusBtn.ZIndex = 2000
	minusBtn.Parent = mainFrame

	local function pressAnim(btn: GuiObject)
		local startPos = btn.Position
		local downPos = UDim2.new(startPos.X.Scale, startPos.X.Offset + 1, startPos.Y.Scale, startPos.Y.Offset + 1)
		local tDown = TweenService:Create(btn, TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = downPos })
		local tUp = TweenService:Create(btn, TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Position = startPos })
		local conn: RBXScriptConnection? = nil
		conn = tDown.Completed:Connect(function()
			if conn then conn:Disconnect() conn = nil end
			tUp:Play()
		end)
		tDown:Play()
	end

	-- Sections panel
	local sectionsPanel = Instance.new("ScrollingFrame")
	sectionsPanel.Name = "SectionsPanel"
	sectionsPanel.BackgroundTransparency = 1
	sectionsPanel.BorderSizePixel = 0
	sectionsPanel.ZIndex = 1002
	sectionsPanel.Parent = mainFrame
	sectionsPanel.ScrollingDirection = Enum.ScrollingDirection.Y
	sectionsPanel.ScrollBarThickness = 0
	sectionsPanel.ElasticBehavior = Enum.ElasticBehavior.WhenScrollable
	sectionsPanel.CanvasSize = UDim2.new(0, 0, 0, 0)
	sectionsPanel.AutomaticCanvasSize = Enum.AutomaticSize.Y

	local sectionsList = Instance.new("UIListLayout")
	sectionsList.FillDirection = Enum.FillDirection.Vertical
	sectionsList.SortOrder = Enum.SortOrder.LayoutOrder
	sectionsList.Padding = UDim.new(0, 2)
	sectionsList.Parent = sectionsPanel

	-- Content scroll inside inner mask
	local contentScroll = Instance.new("ScrollingFrame")
	contentScroll.Name = "ContentScroll"
	contentScroll.BackgroundTransparency = 1
	contentScroll.BorderSizePixel = 0
	contentScroll.ScrollBarThickness = 0
	contentScroll.ScrollingDirection = Enum.ScrollingDirection.Y
	contentScroll.ElasticBehavior = Enum.ElasticBehavior.WhenScrollable
	contentScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	contentScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	contentScroll.ZIndex = 1010
	contentScroll.Parent = innerMask

	local contentPad = Instance.new("UIPadding")
	contentPad.PaddingLeft = UDim.new(0, 10)
	contentPad.PaddingRight = UDim.new(0, 10)
	contentPad.PaddingTop = UDim.new(0, 10)
	contentPad.PaddingBottom = UDim.new(0, 10)
	contentPad.Parent = contentScroll

	local contentList = Instance.new("UIListLayout")
	contentList.FillDirection = Enum.FillDirection.Vertical
	contentList.SortOrder = Enum.SortOrder.LayoutOrder
	contentList.Padding = UDim.new(0, 8)
	contentList.Parent = contentScroll

	local bottomSpacer = Instance.new("Frame")
	bottomSpacer.Name = "BottomSafeSpace"
	bottomSpacer.BackgroundTransparency = 1
	bottomSpacer.BorderSizePixel = 0
	bottomSpacer.Size = UDim2.new(1, 0, 0, INNER_CORNER)
	bottomSpacer.LayoutOrder = 999999
	bottomSpacer.Parent = contentScroll

	-- Dropdown menu handling (single open at a time)
	local openDropdownMenu: Frame? = nil
	local function closeDropdownMenu()
		if openDropdownMenu and openDropdownMenu.Parent then
			openDropdownMenu:Destroy()
		end
		openDropdownMenu = nil
	end

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			if openDropdownMenu then
				closeDropdownMenu()
			end
		end
	end)

	-- Button press fx (only for Button, same feel as now)
	local function buttonPressFX(content: Frame, scaleObj: UIScale)
		local baseColor = ROW_BG
		local brightColor = brighten(ROW_BG, 70)
		content.BackgroundColor3 = brightColor
		TweenService:Create(scaleObj, TweenInfo.new(0.06, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Scale = 0.985 }):Play()
		task.delay(0.1, function()
			if content and content.Parent then
				content.BackgroundColor3 = baseColor
			end
			if scaleObj and scaleObj.Parent then
				TweenService:Create(scaleObj, TweenInfo.new(0.10, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { Scale = 1 }):Play()
			end
		end)
	end

	-- Row factory (same style)
	local function rowBase(parent: Instance, height: number?)
		local row = Instance.new("TextButton")
		row.AutoButtonColor = false
		row.Text = ""
		row.BackgroundTransparency = 1
		row.BorderSizePixel = 0
		row.Size = UDim2.new(1, 0, 0, height or ROW_HEIGHT)
		row.ZIndex = 1011
		row.Parent = parent
		return row
	end

	local function makeRowContent(row: TextButton)
		local content = Instance.new("Frame")
		content.Name = "Content"
		content.BackgroundColor3 = ROW_BG
		content.BackgroundTransparency = ROW_BG_T
		content.BorderSizePixel = 0
		content.AnchorPoint = Vector2.new(0.5, 0.5)
		content.Position = UDim2.new(0.5, 0, 0.5, 0)
		content.Size = UDim2.new(1, 0, 1, 0)
		content.ZIndex = 1011
		content.Parent = row

		local c = Instance.new("UICorner")
		c.CornerRadius = UDim.new(0, ROW_CORNER)
		c.Parent = content

		local scale = Instance.new("UIScale")
		scale.Scale = 1
		scale.Parent = content

		return content, scale
	end

	-- ===== Window Drag (same as now) =====
	local draggingMain = false
	local activeMainInput: InputObject? = nil
	local mainDragStart: Vector3? = nil
	local mainStartPos: UDim2? = nil

	mainFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			draggingMain = true
			activeMainInput = input
			mainDragStart = input.Position
			mainStartPos = mainFrame.Position

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					if activeMainInput == input then
						draggingMain = false
						activeMainInput = nil
					end
				end
			end)
		end
	end)

	UserInputService.InputChanged:Connect(function(input)
		if draggingMain and activeMainInput and input == activeMainInput and mainDragStart and mainStartPos then
			local delta = input.Position - mainDragStart
			mainFrame.Position = UDim2.new(
				mainStartPos.X.Scale, mainStartPos.X.Offset + delta.X,
				mainStartPos.Y.Scale, mainStartPos.Y.Offset + delta.Y
			)
		end
	end)

	-- Close / minimize (same)
	closeBtn.Activated:Connect(function()
		pressAnim(closeBtn)
		task.delay(0.10, function()
			screenGui:Destroy()
		end)
	end)

	minusBtn.Activated:Connect(function()
		pressAnim(minusBtn)
		task.delay(0.10, function()
			mainFrame.Visible = false
		end)
	end)

	-- ===== Window object =====
	local Window = {}
	Window.Sections = {}
	Window._sectionButtons = {}
	Window._selectedSection = nil
	Window._selectedIndex = nil

	-- selection style (same as your sections highlight = inner style)
	local function applySelectionStyle(btn: TextButton, isSelected: boolean)
		btn.BackgroundColor3 = INNER_COLOR
		if isSelected then
			btn.BackgroundTransparency = INNER_T
		else
			btn.BackgroundTransparency = 1
		end
	end

	local function clearContentKeepLayout()
		closeDropdownMenu()
		for _, ch in ipairs(contentScroll:GetChildren()) do
			if ch:IsA("GuiObject") and ch ~= bottomSpacer and not ch:IsA("UIPadding") and not ch:IsA("UIListLayout") then
				ch:Destroy()
			end
		end
	end

	-- Slider: lock only one active slider drag
	local ACTIVE_SLIDER_ROW: GuiObject? = nil

	-- ===== Renderers for elements =====
	local function renderToggle(section, opt)
		local row = rowBase(contentScroll)
		row.Name = "ToggleRow"
		local content, _ = makeRowContent(row)

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Text = opt.Name or "Toggle"
		label.TextColor3 = ParseColor(opt.Color or section.Color or ROW_TEXT_DEFAULT)
		label.Font = ParseFont(opt.Font or section.Font or "SourceSansBold")
		label.TextSize = TEXT_SIZE
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.Position = UDim2.new(0, 10, 0, 0)
		label.Size = UDim2.new(1, -(10 + 10 + PILL_W + 10), 1, 0)
		label.ZIndex = 1012
		label.Parent = content

		local pill = Instance.new("Frame")
		pill.BackgroundColor3 = PILL_OFF
		pill.BackgroundTransparency = 0
		pill.BorderSizePixel = 0
		pill.AnchorPoint = Vector2.new(1, 0.5)
		pill.Position = UDim2.new(1, -10, 0.5, 0)
		pill.Size = UDim2.new(0, PILL_W, 0, PILL_H)
		pill.ZIndex = 1012
		pill.Parent = content

		local pillCorner = Instance.new("UICorner")
		pillCorner.CornerRadius = UDim.new(1, 0)
		pillCorner.Parent = pill

		local dot = Instance.new("Frame")
		dot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		dot.BackgroundTransparency = 0
		dot.BorderSizePixel = 0
		dot.Size = UDim2.new(0, DOT, 0, DOT)
		dot.Position = UDim2.new(0, PILL_PAD, 0.5, -math.floor(DOT / 2))
		dot.ZIndex = 1013
		dot.Parent = pill

		local dotCorner = Instance.new("UICorner")
		dotCorner.CornerRadius = UDim.new(1, 0)
		dotCorner.Parent = dot

		local state = (opt.Default == true)

		local function setState(on: boolean, instant: boolean)
			state = on
			local leftX = PILL_PAD
			local rightX = PILL_W - DOT - PILL_PAD
			local targetX = on and rightX or leftX
			local targetColor = on and ACCENT_GREEN or PILL_OFF

			if instant then
				pill.BackgroundColor3 = targetColor
				dot.Position = UDim2.new(0, targetX, 0.5, -math.floor(DOT / 2))
				return
			end

			TweenService:Create(pill, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				BackgroundColor3 = targetColor
			}):Play()

			TweenService:Create(dot, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
				Position = UDim2.new(0, targetX, 0.5, -math.floor(DOT / 2))
			}):Play()
		end

		setState(state, true)

		row.Activated:Connect(function()
			setState(not state, false)
			if typeof(opt.Callback) == "function" then
				opt.Callback(state)
			end
		end)
	end

	local function renderButton(section, opt)
		local row = rowBase(contentScroll)
		row.Name = "ActionButtonRow"

		local content, scaleObj = makeRowContent(row)

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Text = opt.Name or "Button"
		label.TextColor3 = ParseColor(opt.Color or section.Color or ROW_TEXT_DEFAULT)
		label.Font = ParseFont(opt.Font or section.Font or "SourceSansBold")
		label.TextSize = TEXT_SIZE
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.Position = UDim2.new(0, 10, 0, 0)
		label.Size = UDim2.new(1, -20, 1, 0)
		label.ZIndex = 1012
		label.Parent = content

		row.Activated:Connect(function()
			buttonPressFX(content, scaleObj)
			if typeof(opt.Callback) == "function" then
				opt.Callback()
			end
		end)
	end

	local function renderSlider(section, opt)
		local minValue = tonumber(opt.Min) or 0
		local maxValue = tonumber(opt.Max) or 100
		if maxValue < minValue then
			minValue, maxValue = maxValue, minValue
		end
		local inc = tonumber(opt.Increment) or 1
		if inc <= 0 then inc = 1 end

		local function snap(v: number)
			v = math.clamp(v, minValue, maxValue)
			local steps = (v - minValue) / inc
			local snapped = minValue + (math.floor(steps + 0.5) * inc)
			return math.clamp(snapped, minValue, maxValue)
		end

		local value = snap(tonumber(opt.Default) or minValue)

		local row = rowBase(contentScroll)
		row.Name = "SliderRow"
		local content, _ = makeRowContent(row)

		local INNER_PAD = 10
		local LABEL_W = 62
		local GAP_LABEL_TRACK = 8
		local GAP_TRACK_TO_VALUE = 10

		local trackH = 6
		local knobD = math.floor(trackH * 1.5 + 0.5)
		local valueBoxW = math.floor(48 / 1.3 + 0.5)

		local label = Instance.new("TextLabel")
		label.Name = "SliderLabel"
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Text = opt.Name or "Slider"
		label.TextColor3 = ParseColor(opt.Color or section.Color or ROW_TEXT_DEFAULT)
		label.Font = ParseFont(opt.Font or section.Font or "SourceSansBold")
		label.TextSize = TEXT_SIZE
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.Position = UDim2.new(0, INNER_PAD, 0, 0)
		label.Size = UDim2.new(0, LABEL_W, 1, 0)
		label.ZIndex = 1012
		label.Parent = content

		local valueBox = Instance.new("Frame")
		valueBox.Name = "ValueBox"
		valueBox.BorderSizePixel = 0
		valueBox.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
		valueBox.BackgroundTransparency = 0
		valueBox.AnchorPoint = Vector2.new(1, 0.5)
		valueBox.Position = UDim2.new(1, -INNER_PAD, 0.5, 0)
		valueBox.Size = UDim2.new(0, valueBoxW, 0, math.max(trackH + 8, 16))
		valueBox.ZIndex = 1012
		valueBox.Parent = content

		local valueCorner = Instance.new("UICorner")
		valueCorner.CornerRadius = UDim.new(0, 6)
		valueCorner.Parent = valueBox

		local valueInput = Instance.new("TextBox")
		valueInput.Name = "ValueInput"
		valueInput.BackgroundTransparency = 1
		valueInput.BorderSizePixel = 0
		valueInput.TextColor3 = Color3.fromRGB(255, 255, 255)
		valueInput.Font = Enum.Font.SourceSansBold
		valueInput.TextSize = 14
		valueInput.TextXAlignment = Enum.TextXAlignment.Center
		valueInput.TextYAlignment = Enum.TextYAlignment.Center
		valueInput.ClearTextOnFocus = false
		valueInput.Size = UDim2.new(1, 0, 1, 0)
		valueInput.ZIndex = 1013
		valueInput.Parent = valueBox

		local track = Instance.new("Frame")
		track.Name = "Track"
		track.BorderSizePixel = 0
		track.BackgroundColor3 = PILL_OFF
		track.BackgroundTransparency = 0
		track.AnchorPoint = Vector2.new(0, 0.5)
		track.Position = UDim2.new(0, INNER_PAD + LABEL_W + GAP_LABEL_TRACK, 0.5, 0)
		track.Size = UDim2.new(
			1,
			-((INNER_PAD + LABEL_W + GAP_LABEL_TRACK) + (INNER_PAD + valueBoxW + GAP_TRACK_TO_VALUE)),
			0,
			trackH
		)
		track.ZIndex = 1012
		track.Parent = content

		local trackCorner = Instance.new("UICorner")
		trackCorner.CornerRadius = UDim.new(1, 0)
		trackCorner.Parent = track

		local fill = Instance.new("Frame")
		fill.Name = "Fill"
		fill.BorderSizePixel = 0
		fill.BackgroundColor3 = Color3.fromRGB(105, 105, 105)
		fill.BackgroundTransparency = 0
		fill.Position = UDim2.new(0, 0, 0, 0)
		fill.Size = UDim2.new(0, 0, 1, 0)
		fill.ZIndex = 1013
		fill.Parent = track

		local fillCorner = Instance.new("UICorner")
		fillCorner.CornerRadius = UDim.new(1, 0)
		fillCorner.Parent = fill

		local knob = Instance.new("ImageButton")
		knob.Name = "Knob"
		knob.AutoButtonColor = false
		knob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		knob.BorderSizePixel = 0
		knob.AnchorPoint = Vector2.new(0.5, 0.5)
		knob.Position = UDim2.new(0, 0, 0.5, 0)
		knob.Size = UDim2.new(0, knobD, 0, knobD)
		knob.ZIndex = 1014
		knob.Parent = track

		local knobCorner = Instance.new("UICorner")
		knobCorner.CornerRadius = UDim.new(1, 0)
		knobCorner.Parent = knob

		local function setFromAlpha(a: number, fire: boolean)
			a = math.clamp(a, 0, 1)
			local raw = minValue + a * (maxValue - minValue)
			local newVal = snap(raw)
			if newVal == value then
				-- still update visuals
			else
				value = newVal
				if fire and typeof(opt.Callback) == "function" then
					opt.Callback(value)
				end
			end

			valueInput.Text = tostring(value)

			local w = track.AbsoluteSize.X
			local x = math.clamp(((value - minValue) / (maxValue - minValue)) * w, 0, w)
			knob.Position = UDim2.new(0, x, 0.5, 0)
			fill.Size = UDim2.new(0, x, 1, 0)
		end

		local function setByScreenX(screenX: number, fire: boolean)
			local left = track.AbsolutePosition.X
			local w = track.AbsoluteSize.X
			if w <= 1 then return end
			local a = (screenX - left) / w
			setFromAlpha(a, fire)
		end

		-- init visuals
		task.defer(function()
			local a = 0
			if maxValue ~= minValue then
				a = (value - minValue) / (maxValue - minValue)
			end
			setFromAlpha(a, false)
		end)

		local dragging = false
		local activeInput: InputObject? = nil

		local function beginDrag(input: InputObject)
			if ACTIVE_SLIDER_ROW ~= nil and ACTIVE_SLIDER_ROW ~= row then
				return
			end
			ACTIVE_SLIDER_ROW = row
			dragging = true
			activeInput = input
			setByScreenX(input.Position.X, true)

			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					if activeInput == input then
						dragging = false
						activeInput = nil
						if ACTIVE_SLIDER_ROW == row then
							ACTIVE_SLIDER_ROW = nil
						end
					end
				end
			end)
		end

		knob.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				beginDrag(input)
			end
		end)

		track.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				beginDrag(input)
			end
		end)

		UserInputService.InputChanged:Connect(function(input)
			if dragging and activeInput and input == activeInput and ACTIVE_SLIDER_ROW == row then
				setByScreenX(input.Position.X, true)
			end
		end)

		valueInput.FocusLost:Connect(function()
			local n = tonumber(valueInput.Text)
			if n == nil then
				valueInput.Text = tostring(value)
				return
			end
			n = snap(n)
			if n ~= value then
				value = n
				if typeof(opt.Callback) == "function" then
					opt.Callback(value)
				end
			end
			-- refresh visuals
			local a = 0
			if maxValue ~= minValue then
				a = (value - minValue) / (maxValue - minValue)
			end
			setFromAlpha(a, false)
		end)
	end

	local function renderDropdown(section, opt)
		local options = opt.Options
		if typeof(options) ~= "table" then
			options = { "1", "2", "3" }
		end

		local defaultValue = opt.Default
		if defaultValue == nil then
			defaultValue = options[1]
		end

		local row = rowBase(contentScroll)
		row.Name = "DropdownRow"
		local content, _ = makeRowContent(row)

		local INNER_PAD = 10
		local GAP_TO_MENU = 5

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Text = opt.Name or "Dropdown"
		label.TextColor3 = ParseColor(opt.Color or section.Color or ROW_TEXT_DEFAULT)
		label.Font = ParseFont(opt.Font or section.Font or "SourceSansBold")
		label.TextSize = TEXT_SIZE
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.Position = UDim2.new(0, INNER_PAD, 0, 0)
		label.Size = UDim2.new(1, -(INNER_PAD + 10 + 90), 1, 0)
		label.ZIndex = 1012
		label.Parent = content

		local selectBtn = Instance.new("TextButton")
		selectBtn.AutoButtonColor = false
		selectBtn.BorderSizePixel = 0
		selectBtn.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
		selectBtn.BackgroundTransparency = 0
		selectBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
		selectBtn.Font = Enum.Font.SourceSansBold
		selectBtn.TextSize = 14
		selectBtn.Text = tostring(defaultValue)
		selectBtn.AnchorPoint = Vector2.new(1, 0.5)
		selectBtn.Position = UDim2.new(1, -INNER_PAD, 0.5, 0)
		selectBtn.Size = UDim2.new(0, 90, 0, 22)
		selectBtn.ZIndex = 1013
		selectBtn.Parent = content

		local sc = Instance.new("UICorner")
		sc.CornerRadius = UDim.new(0, 6)
		sc.Parent = selectBtn

		local function openMenu()
			closeDropdownMenu()

			local menu = Instance.new("Frame")
			menu.Name = "DropdownMenu"
			menu.BorderSizePixel = 0
			menu.BackgroundColor3 = Color3.fromRGB(90, 90, 90)
			menu.BackgroundTransparency = 0.3 -- полупрозрачный фон (как ты просил)
			menu.ZIndex = 5000
			menu.Parent = screenGui
			openDropdownMenu = menu

			local menuCorner = Instance.new("UICorner")
			menuCorner.CornerRadius = UDim.new(0, 8)
			menuCorner.Parent = menu

			local menuList = Instance.new("UIListLayout")
			menuList.FillDirection = Enum.FillDirection.Vertical
			menuList.SortOrder = Enum.SortOrder.LayoutOrder
			menuList.Padding = UDim.new(0, 4)
			menuList.Parent = menu

			local mpad = Instance.new("UIPadding")
			mpad.PaddingTop = UDim.new(0, 6)
			mpad.PaddingBottom = UDim.new(0, 6)
			mpad.PaddingLeft = UDim.new(0, 6)
			mpad.PaddingRight = UDim.new(0, 6)
			mpad.Parent = menu

			for i, optVal in ipairs(options) do
				local b = Instance.new("TextButton")
				b.AutoButtonColor = false
				b.BorderSizePixel = 0
				b.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
				b.BackgroundTransparency = 0
				b.TextColor3 = Color3.fromRGB(255, 255, 255)
				b.Font = Enum.Font.SourceSansBold
				b.TextSize = 14
				b.Text = tostring(optVal)
				b.Size = UDim2.new(0, 80, 0, 22)
				b.ZIndex = 5001
				b.LayoutOrder = i
				b.Parent = menu

				local bc = Instance.new("UICorner")
				bc.CornerRadius = UDim.new(0, 6)
				bc.Parent = b

				b.Activated:Connect(function()
					selectBtn.Text = tostring(optVal)
					closeDropdownMenu()
					if typeof(opt.Callback) == "function" then
						opt.Callback(optVal)
					end
				end)
			end

			local absPos = selectBtn.AbsolutePosition
			local absSize = selectBtn.AbsoluteSize
			menu.Size = UDim2.new(0, 92, 0, 6 + (#options * 22) + ((#options - 1) * 4) + 6)
			menu.Position = UDim2.new(0, absPos.X + absSize.X + GAP_TO_MENU, 0, absPos.Y)
		end

		selectBtn.Activated:Connect(function()
			if openDropdownMenu then
				closeDropdownMenu()
			else
				openMenu()
			end
		end)
	end

	local function renderTextBox(section, opt)
		local row = rowBase(contentScroll)
		row.Name = "TextBoxRow"
		local content, _ = makeRowContent(row)

		local INNER_PAD = 10
		local BOX_W = 111 -- как у тебя сейчас (широкий, ~3x)

		local label = Instance.new("TextLabel")
		label.BackgroundTransparency = 1
		label.BorderSizePixel = 0
		label.Text = opt.Name or "Text Box"
		label.TextColor3 = ParseColor(opt.Color or section.Color or ROW_TEXT_DEFAULT)
		label.Font = ParseFont(opt.Font or section.Font or "SourceSansBold")
		label.TextSize = TEXT_SIZE
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.TextYAlignment = Enum.TextYAlignment.Center
		label.Position = UDim2.new(0, INNER_PAD, 0, 0)
		label.Size = UDim2.new(1, -(INNER_PAD + 10 + BOX_W), 1, 0)
		label.ZIndex = 1012
		label.Parent = content

		local box = Instance.new("Frame")
		box.Name = "InputBox"
		box.BorderSizePixel = 0
		box.BackgroundColor3 = Color3.fromRGB(120, 120, 120)
		box.BackgroundTransparency = 0
		box.AnchorPoint = Vector2.new(1, 0.5)
		box.Position = UDim2.new(1, -INNER_PAD, 0.5, 0)
		box.Size = UDim2.new(0, BOX_W, 0, 22)
		box.ZIndex = 1012
		box.Parent = content

		local boxCorner = Instance.new("UICorner")
		boxCorner.CornerRadius = UDim.new(0, 6)
		boxCorner.Parent = box

		local input = Instance.new("TextBox")
		input.Name = "Input"
		input.BackgroundTransparency = 1
		input.BorderSizePixel = 0
		input.ClearTextOnFocus = false

		local def = opt.Default
		if def == nil then def = "" end
		if def == "" then
			input.Text = ""
			input.PlaceholderText = "..."
		else
			input.Text = tostring(def)
			input.PlaceholderText = "..."
		end

		-- центр, белый, и при потере фокуса полупрозрачный
		input.PlaceholderColor3 = Color3.fromRGB(255, 255, 255)
		input.TextColor3 = Color3.fromRGB(255, 255, 255)
		input.TextTransparency = 0.45

		input.Font = Enum.Font.SourceSansBold
		input.TextSize = 14
		input.TextXAlignment = Enum.TextXAlignment.Center
		input.TextYAlignment = Enum.TextYAlignment.Center
		input.Size = UDim2.new(1, 0, 1, 0)
		input.ZIndex = 1013
		input.Parent = box

		input.Focused:Connect(function()
			input.TextTransparency = 0
		end)

		input.FocusLost:Connect(function()
			-- когда отпустили: делаем полупрозрачным
			input.TextTransparency = 0.45
			if typeof(opt.Callback) == "function" then
				opt.Callback(input.Text)
			end
		end)
	end

	local function renderLabel(section, opt)
		local lines = tonumber(opt.Lines) or 3
		if lines < 1 then lines = 1 end

		local rowHeight = 16 + (lines * 14) -- простая высота под строки, вид не ломаем
		local row = rowBase(contentScroll, rowHeight)
		row.Name = "LabelRow"
		local content, _ = makeRowContent(row)

		local text = Instance.new("TextLabel")
		text.BackgroundTransparency = 1
		text.BorderSizePixel = 0
		text.TextColor3 = ParseColor(opt.Color or section.Color or MUTED_TEXT_DEFAULT)
		text.Font = ParseFont(opt.Font or section.Font or "SourceSans")
		text.TextSize = 13
		text.TextXAlignment = Enum.TextXAlignment.Left
		text.TextYAlignment = Enum.TextYAlignment.Top
		text.TextWrapped = true

		text.Text = opt.Text or "Label"
		text.Position = UDim2.new(0, 10, 0, 10)
		text.Size = UDim2.new(1, -20, 1, -20)
		text.ZIndex = 1012
		text.Parent = content
	end

	local function renderHeadText(section, opt)
		local row = rowBase(contentScroll, 30)
		row.Name = "HeadTextRow"

		-- IMPORTANT: no underlay background for HeadText (as you requested earlier)
		-- So we DO NOT use makeRowContent here.
		local container = Instance.new("Frame")
		container.BackgroundTransparency = 1
		container.BorderSizePixel = 0
		container.Size = UDim2.new(1, 0, 1, 0)
		container.Position = UDim2.new(0, 0, 0, 0)
		container.ZIndex = 1011
		container.Parent = row

		local textColor = ParseColor(opt.Color or section.Color or ROW_TEXT_DEFAULT)
		local font = ParseFont(opt.Font or section.Font or "SourceSansBold")
		local lineColor = ParseColor(opt.LineColor or "120,120,120")
		local showLines = (opt.Lines ~= false)

		local INNER_PAD = 10
		local GAP_TEXT_TO_LINE = 10
		local HEAD_W = 90

		local head = Instance.new("TextLabel")
		head.BackgroundTransparency = 1
		head.BorderSizePixel = 0
		head.Text = opt.Text or "Head Text"
		head.TextColor3 = textColor
		head.Font = font
		head.TextSize = 16
		head.TextXAlignment = Enum.TextXAlignment.Center
		head.TextYAlignment = Enum.TextYAlignment.Center
		head.ZIndex = 1013
		head.Parent = container
		head.Size = UDim2.new(0, HEAD_W, 0, 10)
		head.AnchorPoint = Vector2.new(0.5, 0.5)
		head.Position = UDim2.new(0.5, 0, 0.5, 0)

		local leftLine = Instance.new("Frame")
		leftLine.BorderSizePixel = 0
		leftLine.BackgroundColor3 = lineColor
		leftLine.BackgroundTransparency = 0
		leftLine.ZIndex = 1012
		leftLine.Visible = showLines
		leftLine.Parent = container

		local rightLine = Instance.new("Frame")
		rightLine.BorderSizePixel = 0
		rightLine.BackgroundColor3 = lineColor
		rightLine.BackgroundTransparency = 0
		rightLine.ZIndex = 1012
		rightLine.Visible = showLines
		rightLine.Parent = container

		local function layoutLines()
			if not showLines then return end
			local w = container.AbsoluteSize.X
			if w <= 0 then return end
			local available = w - (INNER_PAD * 2) - HEAD_W - (GAP_TEXT_TO_LINE * 2)
			local lineW = math.max(10, math.floor(available / 2))

			leftLine.Size = UDim2.new(0, lineW, 0, 2)
			leftLine.Position = UDim2.new(0, INNER_PAD, 0.5, -1)

			rightLine.Size = UDim2.new(0, lineW, 0, 2)
			rightLine.Position = UDim2.new(1, -INNER_PAD - lineW, 0.5, -1)
		end

		task.defer(layoutLines)
		container:GetPropertyChangedSignal("AbsoluteSize"):Connect(layoutLines)
	end

	-- Renderer dispatch
	local function renderSection(section)
		clearContentKeepLayout()
		for _, el in ipairs(section._elements) do
			if el.Type == "Toggle" then
				renderToggle(section, el.Opt)
			elseif el.Type == "Button" then
				renderButton(section, el.Opt)
			elseif el.Type == "Slider" then
				renderSlider(section, el.Opt)
			elseif el.Type == "Dropdown" then
				renderDropdown(section, el.Opt)
			elseif el.Type == "TextBox" then
				renderTextBox(section, el.Opt)
			elseif el.Type == "Label" then
				renderLabel(section, el.Opt)
			elseif el.Type == "HeadText" then
				renderHeadText(section, el.Opt)
			end
		end
	end

	local function setSelected(idx: number)
		local btn = Window._sectionButtons[idx]
		if not btn then return end
		if Window._selectedIndex == idx then return end

		if Window._selectedIndex then
			local oldBtn = Window._sectionButtons[Window._selectedIndex]
			if oldBtn then applySelectionStyle(oldBtn, false) end
		end

		Window._selectedIndex = idx
		applySelectionStyle(btn, true)

		local section = Window.Sections[idx]
		if section then
			renderSection(section)
		end
	end

	-- Window:AddSection (your strict fields)
	function Window:AddSection(opt)
		opt = opt or {}
		local section = {}
		section.Name = opt.Name or "Section"
		section.Font = ParseFont(opt.Font or "SourceSans")
		section.Color = ParseColor(opt.Color or "#ffffff")
		section._elements = {}

		function section:AddToggle(t)
			t = t or {}
			table.insert(self._elements, { Type = "Toggle", Opt = t })
		end

		function section:AddButton(t)
			t = t or {}
			table.insert(self._elements, { Type = "Button", Opt = t })
		end

		function section:AddSlider(t)
			t = t or {}
			table.insert(self._elements, { Type = "Slider", Opt = t })
		end

		function section:AddDropdown(t)
			t = t or {}
			table.insert(self._elements, { Type = "Dropdown", Opt = t })
		end

		function section:AddTextBox(t)
			t = t or {}
			table.insert(self._elements, { Type = "TextBox", Opt = t })
		end

		function section:AddLabel(t)
			t = t or {}
			table.insert(self._elements, { Type = "Label", Opt = t })
		end

		function section:AddHeadText(t)
			t = t or {}
			table.insert(self._elements, { Type = "HeadText", Opt = t })
		end

		table.insert(Window.Sections, section)

		-- create button on left (same style)
		local idx = #Window.Sections
		local b = Instance.new("TextButton")
		b.Name = "SectionBtn_" .. tostring(idx)
		b.AutoButtonColor = false
		b.BorderSizePixel = 0
		b.Text = section.Name
		b.TextColor3 = Color3.fromRGB(235, 235, 235)
		b.Font = Enum.Font.SourceSans
		b.TextSize = 13
		b.TextXAlignment = Enum.TextXAlignment.Left
		b.LayoutOrder = idx
		b.ZIndex = 1003
		b.Parent = sectionsPanel
		b.Size = UDim2.new(1, 0, 0, 24)

		local pad = Instance.new("UIPadding")
		pad.PaddingLeft = UDim.new(0, 11)
		pad.PaddingRight = UDim.new(0, 1)
		pad.Parent = b

		local c = Instance.new("UICorner")
		c.CornerRadius = UDim.new(0, INNER_CORNER)
		c.Parent = b

		applySelectionStyle(b, false)
		b.Activated:Connect(function()
			setSelected(idx)
		end)

		Window._sectionButtons[idx] = b

		-- if first section, select it
		if idx == 1 then
			setSelected(1)
		end

		return section
	end

	-- Layout function (keeps same geometry as your current UI)
	local function updateLayout()
		local mainTopAbs = mainFrame.AbsolutePosition.Y
		local innerTopAbs = innerFrame.AbsolutePosition.Y

		local headerHeight = math.floor((innerTopAbs - mainTopAbs) - (HEADER_TOP + HEADER_BOTTOM))
		if headerHeight < 1 then headerHeight = 1 end

		local iconSize = math.max(12, math.floor(headerHeight * 0.60))

		closeBtn.Size = UDim2.new(0, iconSize, 0, iconSize)
		closeBtn.Position = UDim2.new(1, -ICON_MARGIN, 0, ICON_MARGIN)

		minusBtn.Size = UDim2.new(0, iconSize, 0, iconSize)
		minusBtn.Position = UDim2.new(1, -(ICON_MARGIN + iconSize + ICON_GAP), 0, ICON_MARGIN)

		image.Position = UDim2.new(0, LEFT_TO_IMAGE, 0, HEADER_TOP)
		image.Size = UDim2.new(0, headerHeight, 0, headerHeight)

		textWrap.Position = UDim2.new(0, LEFT_TO_IMAGE + headerHeight + IMAGE_TO_TEXT, 0, HEADER_TOP)

		local reservedRight = ICON_MARGIN + iconSize + ICON_GAP + iconSize + 12
		local availableW = mainFrame.AbsoluteSize.X - (LEFT_TO_IMAGE + headerHeight + IMAGE_TO_TEXT) - reservedRight
		if availableW < 10 then availableW = 10 end
		textWrap.Size = UDim2.new(0, availableW, 0, headerHeight)

		local usableH = headerHeight - 4
		if usableH < 2 then usableH = 2 end

		local titleH = math.floor(usableH * 0.58)
		local descH = usableH - titleH
		title.Size = UDim2.new(1, 0, 0, titleH)
		desc.Size = UDim2.new(1, 0, 0, descH)

		local mainW = mainFrame.AbsoluteSize.X
		local mainH = mainFrame.AbsoluteSize.Y
		local innerW = innerFrame.AbsoluteSize.X
		local innerLeft = mainW - 10 - innerW

		local panelX = 3
		local panelRight = innerLeft - 3
		local panelW = panelRight - panelX
		if panelW < 20 then panelW = 20 end

		local panelY = math.floor(innerTopAbs - mainTopAbs)
		local panelH = mainH - panelY - 10
		if panelH < 20 then panelH = 20 end

		sectionsPanel.Position = UDim2.new(0, panelX, 0, panelY)
		sectionsPanel.Size = UDim2.new(0, panelW, 0, panelH)

		contentScroll.Position = UDim2.new(0, 0, 0, 0)
		contentScroll.Size = UDim2.new(1, 0, 1, 0)
	end

	RunService.Heartbeat:Wait()
	updateLayout()
	mainFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateLayout)
	mainFrame:GetPropertyChangedSignal("AbsolutePosition"):Connect(updateLayout)
	innerFrame:GetPropertyChangedSignal("AbsolutePosition"):Connect(updateLayout)
	innerFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateLayout)

	return Window
end

return setmetatable({}, XuilanLib)
